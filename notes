-------------------------------------------------------------------------------------------------------
INTRODUCTION:
-------------------------------------------------------------------------------------------------------
Basics of docker:
    Dockerfile
    docker build
    docker pull
    dockr push 

-------------------------------------------------------------------------------------------------------
REGISTRY:
-------------------------------------------------------------------------------------------------------
It consists of Container registry and Artifact registry. 

Container registry:
    It is of host-name/project-id/image-name:tag 
    Host name is not specific to region.
    No IAM role is tagged.
    Host name is,
      gcr.io - Stores in United states data center.
      asia.gcr.io - Stores in asia data center.
      eu.gcr.io - Stores in EU data center.
      us.gcr.io - Stores in Unites states data center.
    $DEVSHELL_PROJECT_ID  - Environment variable to get current project id. 
    Internally creates bucket to store registry.
      
Artifact registry:
    It is advance to container registry.
    It supports roles. (reader, Writer, Administrator & repo administrator created by default)
    It isused to store images, artifacts like jfrog artifactory.
    Multiple repositories can create per project.
    Can create regional or multi regional level repositories.
    URL is us-central1-docker.pkg.dev/$PROJECT_ID/repo/image:tag
            us-central-1 can change depends upon region selected.    
    Configuration: 
        gcloud auth configure-docker us-central1-docker.pkg.dev  -> To configure docker to use google cloud cli to authenticate request to artifact registry in us-central.

-------------------------------------------------------------------------------------------------------
DEPLOY APPLICATIONS:
-------------------------------------------------------------------------------------------------------

Compute Options:

    Compute Engine: Like ec2.
    Kubernetes: like eks. Used to deploy containarized application. 
    App Engine: Serverless web application deployment.
    Cloud Run: Used to deploy containerized application.
    Cloud Function: Event triggered based function. 
    
Deployment Method:

    Blue/green
    Canary
    Rolling 
    Traffic Splitting: Send traffic to small percentage of users first (5% to v2 and 95% to v1 stable). It is used for A/B testing.

Google Cloud Function:

    It is event based trigger. 
        Events can be http, pub/sub, storage, firestore.
    Only one version active at any time, so it cannot roll back to previous version if any failure.
    To overcome this, require to create new functions and loadbalance it.
    
Google App Engine:

    It is used to deploy web application.
    It is earliest product and serverless. 
    Only one app engine can be deployed for one project.
    Environmant consists of,
        Standard
        Flexible    -   CUsom runtime.
    To deploy application, it requires,
        requirements.txt (for python)
        main.py (for python)
        app.yaml 
    Commands: 
        gcloud app deploy       -> deploy application and promote version.
        gcloud app deploy --no-promote --version name     -> deploy application code but not implement. 
    In Version, can Migrate Traffic (100%) and Split Traffic (partial)

Cloud Run:

    It introduced recently.
    Serverless 
    Its better version of app engine.
    Deploy containarized application.
    It is like ECS (to create a service)
    It is like AWS Batch (to create a job)
    Can "Edit and Deploy New revision" -> Manage revison to split traffic.

GKE (Google Kubernets Engine):

    It consists of,
        Create cluster:
            Node pools - create no of nodes.
        Workload deployment:
            create pods and deployments. 
        Expose application:
            Create a services type and expose the applications.
    
Compute Engine:

    General purpose computing machine.
    2 ways of deployment,
        containarized app
        non containarized app.
    Can install startup script (user data in aws)

Instance Template:

    It is like launch template/launch configuration in AWS.
    Create instance from template.
    
Instance Group:

    This is Auto Sacling Group (ASG) in AWS. 
    Used to manage group of instances.
    It consists of,
        New managed instance group (stateless):
                Give min and max no of instances.
                All machine family type is same. 
        New managed instance group (stateful):
                Give NO min and max no of instances but can select no of instances. 
        New unmanaged instance group:
                Manually manage group of load balancing VMs.
                Can select diff vm machine family type. 
                
Load balancer:
    
    create a load balancer type (http, tcp, udp)
    In backend service, select the instance group.


-------------------------------------------------------------------------------------------------------
PIPELINES:
-------------------------------------------------------------------------------------------------------

Source Code Management:
    Cloud Source Repository.

Build:
    Cloud Build: 
        Trigger based on event.
        Source code repository and branch. 
        Configuration Type: 
            Support yaml/json (cloudbuild.yaml)
            dockerfile 
            buildpacks 
        Incase of dockerfile, choose the registry name. 
        Can run manual to trigger.
        https://cloud.google.com/build/docs/build-config-file-schema

Artifact Storage: 
    Artifact Registry 

Deploy:
    Cloud Deploy 

-------------------------------------------------------------------------------------------------------

Pipeline 1 (Create docker image and push to registry):

    Step1: Setup a source repository
        Cloud Source Repository -> Select project ID  & Repo name.
        Once repo is created, it can clone repo and push the code to repo.

    Step2: Setup a cloud build 
        Select type as dockerfile and source as repository.
        Once build completed, image placed in container registry.

-------------------------------------------------------------------------------------------------------        

Pipeline 2 (Deploy python app to App Engine):

    Step1: Setup a source repository. 
    
    Step2:  Create a cloudbuild.yaml file and app.yaml for app engine.

        cloudbuild.yaml 
        steps:
        - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
        entrypoint: 'bash'
        args: ['-c','gcloud config set app/cloud_build_timeout 1600 && gcloud app deploy']
        options:
        logging: CLOUD_LOGGING_ONLY
        timeout: 1600s

        app.yaml 
        runtime: python311 # or another supported version

-------------------------------------------------------------------------------------------------------                

Pipeline 3 (Deploy to Google Cloud Function):

    Step1: Setup a source repository. 

    Step2:  It requires, 
                cloudbuild.yaml 
                function-source.zip 

    cloudbuild.yaml
    steps:
    -   name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
        args:
        - gcloud
        - functions
        - deploy
        - home
        - --region=us-central1
        - --source=.
        - --trigger-http
        - --runtime=python37
        - --allow-unauthenticated
    options:
    logging: CLOUD_LOGGING_ONLY
            
-------------------------------------------------------------------------------------------------------                

Pipeline 4 (Deploy to google run):

    Step1: create a source repo. 

    Step 2: It requires, 
        Dockerfile
        Source code 
        cloudbuild.yaml 

        cloudbuild.yaml
        steps:
        # build image
        - name: 'gcr.io/cloud-builders/docker'
          args: ['build','-t','gcr.io/gcp-devops-learn-381106/runimage','.']
        #push image to registry
        - name: 'gcr.io/cloud-builders/docker'
          args: ['push','gcr.io/gcp-devops-learn-381106/runimage']
        #deploy to cloudrun
        - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
          entrypoint: gcloud
          args: ['run','deploy','myfirstrun','--image','gcp-devops-learn-381106/runimage','--region','us-central1','allow-unauthenticated']
        images:
        - gcr.io/gcp-devops-learn-381106/runimage
        
-------------------------------------------------------------------------------------------------------                

Pipeline 5 (Deploy to GKE):

    Step 1:
        Create GKE cluster and some sample images and do workload (deployment)
        Create load balancer service. 

    Step2:
        Create source code repo 
    
    Step3: 
        cloudbuild.yaml 
        steps:
        - name: 'gcr.io/cloud-builders/git'
          args: ['clone','repo-path']
        - name: 'gcr.io/cloud-builders/docker'
          args: ['build']
        - name: 'gcr.io/cloud-builders/docker'
          args: ['push']
        substitutions:
          PROJECT_ID: 
          CINAME: 
          VERSIOn: 
        #Below only updates, image name to existing deployment. 
        - name: 'gcr.io/cloud-builders/kubectl'
          args: [kubectl set image deploy deploy-name image-name]
          env: 
          - 'CLOUDSDK_COMPUTE_ZONE=useast-1a'
          - 'CLOUDSDK_CONTAINER_CLUSTER=cluster-name'
        

-------------------------------------------------------------------------------------------------------
JENKINS:
-------------------------------------------------------------------------------------------------------

To integrate with Jenkins:

From "Deployment Manager", can search in market place and install tools like jenkins, wordpress etc. 

    1. Can search Jenkins and select "Google click to deploy" from Marketplace. 
    2. It creates VM using Jenkins Image.
    3. In underlying uses Compute engine, Cloud deployment manager and Cloud runtime.
    4. Input disk size and other parameters.
    5. Once deployed, it will give URL and credentials to login. 
    
-------------------------------------------------------------------------------------------------------
SECURE PIPELINE:
-------------------------------------------------------------------------------------------------------

Secure Container Deployment: 

    1. can use Google base image: 
            Google base image can found in market place. 
            Google uses this base image for their own application deployment. 
    2. Container Analysis.
    3. Binary Authorization.
    
Container Scanning API:
    
    Works same in both artifact registry and container registry. 
    Automated vulnarability scanning:
        whenever image is uploaded, it does auto scanning. 
    Manual vulnarability scanning: 
        gcloud artifacts docker images scan imageurl --remote 
        
    Container Registry -> Settings -> Vulnarability scanning -> Turn ON : Existing images will not be scanned but only new images uploaded.
    
    
Binary Authorization: 

    How to prevent deployment if any vulnarabilities. 
    It is deploy time security control. 
    It applies on GKE & CLoud Run.
    It is policy to maintain. 
    Security -> Binary authorization -> Enable (first time)
    Default Rule: 
        Allow all images
        Disallow all images
        Require attestations - allow only verified by attestors.
            1. Create attestator.
                    require public key (create using kms)
            2. Authorize the image using gcloud command. 
        
    Configure Binary Authorization on Cloud Run:

            While create cloud run, under security require to enable "binary auth".

    Configure Binary Authorization on GKE:

            Cluster -> Security -> Enable Binary Authorization.

    
-------------------------------------------------------------------------------------------------------
CLOUD MONITORING SERVICE:
-------------------------------------------------------------------------------------------------------

CloudOps Tools:

    Logging and Monitoring of applications.

    Monitoring -> Dashboards -> Can create custom dashboard or use google dashboard. 

    Ops agent is require to capture additional information like memory. 

Installing Ops Agent in VM: 

    https://cloud.google.com/stackdriver/docs/solutions/agents/ops-agent/installation

Create a custom dashboard:

    Monitoring -> Dashboard -> Create dashboard. 
    For each chart, have one metrics tagged. 
    Can place multiple charts. 
    
Setup Uptime Check:
    
    Used to check whether system application is up and running.
    It consists of,
        target 
        health check
        Notification
     
     Alert Policy:
            Create a alert condition based on metrics and threshold and then send notification. 
            
Group: 
    It helps to group resources and apply monitoring.
    
    
-------------------------------------------------------------------------------------------------------
CLOUD MONITORING SERVICE:
-------------------------------------------------------------------------------------------------------    
    
            
            
            
            
        
        
    
    
    



    


        
            
            
        
    












